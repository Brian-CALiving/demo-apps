<?xml version="1.0" encoding="UTF-8"?>
<article xmlns="http://www.w3.org/1999/xhtml" class="templates:surround?with=templates/page.html&amp;at=content">
    <h1 class="front-title">Basic XQuery Examples</h1>
    <p>This page contains a collection of simple XQuery examples which should give a first glimpse of what's possible
    with eXist and XQuery. To learn more about XQuery, we recommend to head over to the excellent
    <a href="http://en.wikibooks.org/wiki/XQuery">XQuery Wikibook</a> or buy one of the available books
    on XQuery.</p>
    <p>Though the syntactic elements of XQuery can be learned quickly, it is a functional language and it may
    take some time to get a feel for it if you are coming from a procedural world.</p>
    <section>
        <h2>Simple expressions using the full-text index</h2>
        <section>
            <h3>Find out where Juliet talks about love</h3>
            <p>In the following, Jon Bosak's edition of the Shakespeare's Hamlet, Macbeth, and Romeo and Juilet are queried..</p>
            <pre class="templates:display-source">
    //SPEECH[ft:query(., 'love')][SPEAKER = "JULIET"]
            </pre>
        </section>
        <section>
            <h3>Search for a phrase</h3>
            <pre class="templates:display-source">
    //SPEECH[ft:query(., '"fenny snake"')]
</pre>
        </section>
        <section>
            <h3>Find speeches in which "love" and "father" occur closely together, using XML query syntax:</h3>
            <pre class="templates:display-source">
let $query :=
    &lt;query&gt;
        &lt;near slop="20"&gt;&lt;term&gt;love&lt;/term&gt;&lt;near&gt;father&lt;/near&gt;&lt;/near&gt;
    &lt;/query&gt;
return //SPEECH[ft:query(., $query)]
            </pre>
        </section>
        <section>
            <h3>Find speeches in which "boil" and "bubble" occur, ordering them by full-text match score</h3>
            <pre class="templates:display-source">
for $m in //SPEECH[ft:query(., "boil bubble")]
let $score := ft:score($m)
order by $score descending
return &lt;m score="{$score}"&gt;{$m}&lt;/m&gt;
</pre>
        </section>
    </section>
    <section>
        <h2>Functions and recursion</h2>
        <section>
            <h3>Compute the factorial of a given integer</h3>
            <pre class="templates:display-source">
xquery version "1.0";

declare function local:fact($n as xs:integer) {
    if ($n eq 1) then
        $n
    else
        $n * local:fact($n - 1)
};

local:fact(6)
            </pre>
        </section>
    </section>
    <section>
        <h2>Generating HTML</h2>
        <section>
            <h3>Create a 10x10 table and color the cells</h3>
            <pre class="templates:display-source">
xquery version "1.0";
(: $Id: table.xq 6434 2007-08-28 18:59:23Z ellefj $ :)
(: An example found in Saxon: creates a table with 10x10 cells :)

declare namespace f="http://my-namespaces.org";

declare function f:background-color($x as xs:double, $y as xs:integer)
as xs:string {    
	if($x mod 2 + $y mod 2 &lt;= 0) then "lightgreen"
	else if($y mod 2 &lt;= 0) then "yellow"
	else if($x mod 2 &lt;= 0) then "lightblue"
	else "white"
};

&lt;body&gt;
	&lt;table&gt;{
	for $y in 1 to 10 return
		&lt;tr&gt;
		{
			for $x in 1 to 10 return
				let $bg := f:background-color($x, $y),
					$prod := $x * $y
				return
					&lt;td bgcolor="{$bg}"&gt;
						{if ($y &gt; 1 and $x &gt; 1) then $prod else &lt;b&gt;{$prod}&lt;/b&gt;}
					&lt;/td&gt;
		}
		&lt;/tr&gt;
	}&lt;/table&gt;
&lt;/body&gt;
            </pre>
        </section>
        <section>
            <h3>Create a multiplication table</h3>
            <pre class="templates:display-source">
xquery version "1.0";
declare option exist:serialize "method=html5 media-type=text/html";
declare variable $max := 20;

&lt;table border="1" width="100%"&gt;
    &lt;th&gt;1 x 1&lt;/th&gt;
    {
        for $i in (1 to $max)
        return
            &lt;th&gt;{ $i}&lt;/th&gt;
    }
      
    {
        for $a in (1 to $max)  
        return 
            &lt;tr&gt;
                &lt;th&gt;{ $a,"*"}&lt;/th&gt;
                
                {
                    for $b in (1 to $max)
                    return
                        if ($a = $b) then
                            &lt;td bgcolor="#F46978"&gt;{$a * $b}&lt;/td&gt;
                        else if ($a mod 2) then
                            &lt;td bgcolor="#A46978"&gt;{$a * $b}&lt;/td&gt; 
                        else
                            &lt;td bgcolor="#A09224"&gt;{$a * $b}&lt;/td&gt; 
                }            
            &lt;/tr&gt;
  
    }
&lt;/table&gt;</pre>
            <p>To view the output of this query as HTML, save it to the database from within eXide, e.g. as
            /db/test.xql. You can then call it by entering the following URL into your browser:</p>
            <p>
                <a href="http://localhost:8080/exist/rest/db/test.xql">http://localhost:8080/exist/rest/db/test.xql</a>
            </p>
        </section>
        <section>
            <h3>Generate a list of the acts and scenes in Hamlet, with the roles appearing in each scene</h3>
            <pre class="templates:display-source">
declare option exist:serialize "method=html5 media-type=text/html";

&lt;html&gt;
    &lt;body&gt;{
        for $act in doc("/db/demo/data/hamlet.xml")/PLAY/ACT
        return
            &lt;ul&gt;
                &lt;li&gt;
                    &lt;h2&gt;{$act/TITLE/text()}&lt;/h2&gt;
                    &lt;ul&gt;
                    {
                        for $scene in $act/SCENE return
                            &lt;li&gt;
                                &lt;h3&gt;{$scene/TITLE/text()}&lt;/h3&gt;
                                &lt;ul&gt;
                                {
                                    for $speaker in distinct-values($scene//SPEAKER)
                                    order by $speaker return
                                        &lt;li&gt;{$speaker}&lt;/li&gt;
                                }
                                &lt;/ul&gt;
                            &lt;/li&gt;
                    }
                    &lt;/ul&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
    }&lt;/body&gt;
&lt;/html&gt;
</pre>
            <p>To view the output of this query as HTML, save it to the database from within eXide, e.g. as
            /db/test.xql. You can then call it by entering the following URL into your browser:</p>
            <p>
                <a href="http://localhost:8080/exist/rest/db/test.xql">http://localhost:8080/exist/rest/db/test.xql</a>
            </p>
        </section>
    </section>
    <section>
        <h2>Querying a database</h2>
        <p>The following queries use the <a href="http://dbis.informatik.uni-goettingen.de/Mondial/">Mondial</a>
        database, a data set compiled by the Universität Göttingen.</p>
        <section>
            <h3>For each country, list the 3 cities with the highest population</h3>
            <pre class="templates:display-source">
(:  This script accesses the mondial database, which can be
    found at http://dbis.informatik.uni-goettingen.de/Mondial/ :)
for $country in /mondial/country
let $cities := 
    (for $city in $country//city[population] 
    order by xs:integer($city/population[1]) descending 
    return $city)
order by $country/name
return
    &lt;country name="{$country/name}"&gt;
    {
        subsequence($cities, 1, 3)
    }
    &lt;/country&gt;</pre>
        </section>
        <section>
            <h3>Find all Spanish provinces and their cities</h3>
            <pre class="templates:display-source">
xquery version "1.0";

let $country := collection("/db/demo/data")/mondial/country[name = 'Spain']
for $province in $country/province
order by $province/name
return
    &lt;province&gt;
    	{$province/name}
		{
			for $city in $country//city[@province=$province/@id]
			order by $city/name
			return $city
		}
	&lt;/province&gt;
            </pre>
        </section>
        <section>
            <h3>Find the countries with the largest Roman Catholic population</h3>
            <pre class="templates:display-source">
for $country in /mondial/country
where some $r in $country/religions satisfies $r = "Roman Catholic"
order by $country/religions[. = "Roman Catholic"]/@percentage cast as xs:double descending
return
  &lt;country name="{$country/name}"&gt;
    {$country/religions}
  &lt;/country&gt;
</pre>
        </section>
    </section>
    <div class="source-links">
        <p>View source: <a href="index.html" class="templates:load-source">this page</a>.</p>
    </div>
</article>